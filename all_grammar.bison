/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_ARRAY
%token TOKEN_BOOLEAN
%token TOKEN_CHARACTER
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FCALL
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_IDENT
%token TOKEN_INTEGER_LITERAL
%token TOKEN_CHARACTER_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_LBRACK
%token TOKEN_RBRACK
%token TOKEN_LBRACE
%token TOKEN_RBRACE
%token TOKEN_LPAREN
%token TOKEN_RPAREN
%token TOKEN_INC
%token TOKEN_DEC
%token TOKEN_NEG
%token TOKEN_POW
%token TOKEN_MULT
%token TOKEN_DIV
%token TOKEN_MOD
%token TOKEN_ADD
%token TOKEN_LT
%token TOKEN_LE
%token TOKEN_GT
%token TOKEN_GE
%token TOKEN_EQ_COMP
%token TOKEN_NE_COMP
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_NOT
%token TOKEN_ASSIGN
%token TOKEN_COMMA
%token TOKEN_COLON
%token TOKEN_SC
%token TOKEN_WS
%token TOKEN_CPP_COMMENT
%token TOKEN_C_COMMENT
%token TOKEN_WHILE
%token TOKEN_EOF
%token TOKEN_OTHER

%{

#include <math.h>
#include <stdio.h>
#include "expr.h"

/*%}

%union {
    struct expr *expr;
};
%{*/

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/

#define YYSTYPE struct expr *

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct expr * parser_result = 0;

%}

%%

/* Here is the grammar: program is the start symbol. */
Xprogram     
X    : decl_list
	;

Xdecl_list   
X   : decl_list decl
X   |
    ;

Xdecl        
X   : ident TOKEN_COLON type TOKEN_ASSIGN expression TOKEN_SC
X   | ident TOKEN_COLON type TOKEN_SC
X   | ident TOKEN_COLON type TOKEN_ASSIGN TOKEN_LBRACE stmt_list TOKEN_RBRACE
X/*    | ident TOKEN_COLON type TOKEN_ASSIGN TOKEN_LBRACE initializer_list TOKEN_RBRACE*/
    ;

X/*initializer_list
    : non_empty_expr_list expression
    | expression
    ;*/

Xtype        
    : TOKEN_STRING
    | TOKEN_CHARACTER
    | TOKEN_INTEGER
    | TOKEN_BOOLEAN
    | TOKEN_VOID
    | TOKEN_ARRAY TOKEN_LBRACK optional_expression TOKEN_RBRACK type
    | TOKEN_FCALL type TOKEN_LPAREN param_list TOKEN_RPAREN
    ;

stmt_list   
    : 
    | stmt_list stmt
    ;

stmt        
    : TOKEN_IF TOKEN_LPAREN expression TOKEN_RPAREN matched_stmt TOKEN_ELSE stmt
    | TOKEN_IF TOKEN_LPAREN expression TOKEN_RPAREN stmt
    | decl
    | return_stmt
    | print_stmt
    | optional_expression TOKEN_SC
    | TOKEN_FOR TOKEN_LPAREN optional_expression TOKEN_SC optional_expression TOKEN_SC optional_expression TOKEN_RPAREN stmt
    | TOKEN_LBRACE stmt_list TOKEN_RBRACE
    ;

matched_stmt 
    : TOKEN_IF TOKEN_LPAREN expression TOKEN_RPAREN matched_stmt TOKEN_ELSE matched_stmt
    | decl
    | return_stmt
    | print_stmt
    | optional_expression TOKEN_SC
    | TOKEN_FOR TOKEN_LPAREN optional_expression TOKEN_SC optional_expression TOKEN_SC optional_expression TOKEN_RPAREN matched_stmt
    | TOKEN_LBRACE stmt_list TOKEN_RBRACE
    ;

return_stmt 
    : TOKEN_RETURN optional_expression TOKEN_SC
    ;

print_stmt  
    : TOKEN_PRINT optional_expression_list TOKEN_SC
    ;

Xoptional_expression_list 
    : 
    | expression
    | non_empty_expr_list expression
    ;

Xoptional_expression 
    : 
    | expression
    ;

Xexpression  
    : assign_level_expr
    ;
    
Xassign_level_expr
    : assign_level_expr TOKEN_ASSIGN or_comparison_expr
    | or_comparison_expr
    ;
    
Xor_comparison_expr
    : or_comparison_expr TOKEN_OR and_comparison_expr
    | and_comparison_expr
    ;
    
Xand_comparison_expr
    : and_comparison_expr TOKEN_AND eq_comparison_expr
    | eq_comparison_expr
    ;
    
Xeq_comparison_expr
    : eq_comparison_expr TOKEN_EQ_COMP value_comparison_expr
    | eq_comparison_expr TOKEN_NE_COMP value_comparison_expr
    | value_comparison_expr
    ;

Xvalue_comparison_expr
    : value_comparison_expr TOKEN_LT add_level_expr
    | value_comparison_expr TOKEN_LE add_level_expr
    | value_comparison_expr TOKEN_GT add_level_expr
    | value_comparison_expr TOKEN_GE add_level_expr
    | add_level_expr
    ;

Xadd_level_expr
    : add_level_expr TOKEN_ADD mult_level_expr
    | add_level_expr TOKEN_NEG mult_level_expr
    | mult_level_expr
    ;

Xmult_level_expr 
    : mult_level_expr TOKEN_MULT base_level_expr
    | mult_level_expr TOKEN_DIV base_level_expr
    | mult_level_expr TOKEN_MOD base_level_expr
    | exponent_level_expr
    ;

Xexponent_level_expr
    : exponent_level_expr TOKEN_POW unary_level_expr
    | unary_level_expr
    ;

Xunary_level_expr
    : TOKEN_NOT base_level_expr
    | TOKEN_NEG base_level_expr
    | base_level_expr
    ;

Xbase_level_expr
X   : ident
X   | TOKEN_INTEGER_LITERAL
X   | TOKEN_STRING_LITERAL
X   | TOKEN_CHARACTER_LITERAL
X   | TOKEN_TRUE
X   | TOKEN_FALSE
X   | TOKEN_LPAREN expression TOKEN_RPAREN
X   | TOKEN_LBRACK expression TOKEN_RBRACK
X   | ident TOKEN_LPAREN param_list TOKEN_RPAREN
X   | base_level_expr TOKEN_INC /* is this right? */
X   | base_level_expr TOKEN_DEC /* is this right? */
    ;

Xnon_empty_expr_list 
    : expression TOKEN_COMMA
    ;

Xparam_list  
    : non_empty_param_list param
    | param
    |
    ;

Xnon_empty_param_list 
    : param TOKEN_COMMA
    ;

Xparam       
    : ident TOKEN_COLON type
    ;

Xident       
    : TOKEN_IDENT /* need to add to the symbol table, so this token gets its own NT */
    ;

%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
	return -1;
}
