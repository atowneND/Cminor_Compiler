/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%token TOKEN_ARRAY
%token TOKEN_NOT
%token TOKEN_BOOLEAN
%token TOKEN_CHARACTER
%token TOKEN_ELSE
%token TOKEN_FALSE
%token TOKEN_FOR
%token TOKEN_FCALL
%token TOKEN_IF
%token TOKEN_INTEGER
%token TOKEN_PRINT
%token TOKEN_RETURN
%token TOKEN_STRING
%token TOKEN_TRUE
%token TOKEN_VOID
%token TOKEN_WHILE
%token TOKEN_IDENT
%token TOKEN_INTEGER_LITERAL
%token TOKEN_CHARACTER_LITERAL
%token TOKEN_STRING_LITERAL
%token TOKEN_LBRACK
%token TOKEN_RBRACK
%token TOKEN_LBRACE
%token TOKEN_RBRACE
%token TOKEN_LPAREN
%token TOKEN_RPAREN
%token TOKEN_INC
%token TOKEN_DEC
%token TOKEN_NEG
%token TOKEN_POW
%token TOKEN_MULT
%token TOKEN_DIV
%token TOKEN_MOD
%token TOKEN_ADD
%token TOKEN_LT
%token TOKEN_LE
%token TOKEN_GT
%token TOKEN_GE
%token TOKEN_EQ_COMP
%token TOKEN_NE_COMP
%token TOKEN_AND
%token TOKEN_OR
%token TOKEN_ASSIGN
%token TOKEN_CPP_COMMENT
%token TOKEN_C_COMMENT
%token TOKEN_COMMA
%token TOKEN_COLON
%token TOKEN_SC
%token TOKEN_WS
%token TOKEN_OTHER
%token TOKEN_EOF

%{

#include <math.h>
#include <stdio.h>
/*#include "expr.h"*/

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are returning a pointer to an expression.
*/

#define YYSTYPE struct expr *

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct expr * parser_result = 0;

%}

%%

/* Here is the grammar: program is the start symbol. */
program     
    : expr
    ;

expr
    : assign_level_expr
    ;
    
assign_level_expr
    : assign_level_expr TOKEN_ASSIGN or_comparison_expr
    | or_comparison_expr
    ;
    
or_comparison_expr
    : or_comparison_expr TOKEN_OR and_comparison_expr
    | and_comparison_expr
    ;
    
and_comparison_expr
    : and_comparison_expr TOKEN_AND eq_comparison_expr
    | eq_comparison_expr
    ;
    
eq_comparison_expr
    : eq_comparison_expr TOKEN_EQ_COMP value_comparison_expr
    | eq_comparison_expr TOKEN_NE_COMP value_comparison_expr
    | value_comparison_expr
    ;

value_comparison_expr
    : value_comparison_expr TOKEN_LT add_level_expr
    | value_comparison_expr TOKEN_LE add_level_expr
    | value_comparison_expr TOKEN_GT add_level_expr
    | value_comparison_expr TOKEN_GE add_level_expr
    | add_level_expr
    ;

add_level_expr
    : add_level_expr TOKEN_ADD mult_level_expr
    | add_level_expr TOKEN_NEG mult_level_expr
    | mult_level_expr
    ;

mult_level_expr 
    : mult_level_expr TOKEN_MULT base_level_expr
    | mult_level_expr TOKEN_DIV base_level_expr
    | mult_level_expr TOKEN_MOD base_level_expr
    | exponent_level_expr
    ;

exponent_level_expr
    : exponent_level_expr TOKEN_POW unary_level_expr
    | unary_level_expr
    ;

unary_level_expr
    : TOKEN_NOT base_level_expr
    /*| TOKEN_NEG base_level_expr */
    | base_level_expr
    ;

base_level_expr
    : ident
    | TOKEN_LPAREN expr TOKEN_RPAREN
    | TOKEN_LBRACK expr TOKEN_RBRACK
    | ident TOKEN_LPAREN param_list TOKEN_RPAREN
    /*| expr TOKEN_INC
    | expr TOKEN_DEC */
    ;

/*top_level_expr*/
/*    : TOKEN_NEG base_level_expr*/
/*    | base_level_expr*/
/*    ;*/

/*base_level_expr*/
/*    : ident*/
/*    | TOKEN_LPAREN expr TOKEN_RPAREN*/
/*    | TOKEN_LBRACK expr TOKEN_RBRACK*/
/*    | ident TOKEN_LPAREN param_list TOKEN_RPAREN*/
/*    | expr TOKEN_INC*/
/*    | expr TOKEN_DEC*/
/*    ;*/

param_list  
    : non_empty_param_list param
    | param
    |
    ;

non_empty_param_list 
    : param TOKEN_COMMA
    ;

param       
    : ident TOKEN_COLON type
    ;

type        
    : TOKEN_STRING
    | TOKEN_CHARACTER
    | TOKEN_INTEGER
    | TOKEN_BOOLEAN
    | TOKEN_VOID
    ;

ident
    : TOKEN_IDENT
    ;

%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
}
